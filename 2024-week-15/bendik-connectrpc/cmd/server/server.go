package main

import (
	"context"
	"errors"
	"fmt"
	"log"
	"net/http"

	storev1 "github.com/coopnorge/bendik-connectrpc/coopnorge/store/v1"                       // generated by protoc-gen-go
	storev1connect "github.com/coopnorge/bendik-connectrpc/coopnorge/store/v1/storev1connect" // generated by protoc-gen-connect-go
	signals "github.com/coopnorge/go-signal-lib"

	"connectrpc.com/connect"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"
	"golang.org/x/sync/errgroup"
)

func main() {
	ctx, cancel := signals.HandleSignals(context.Background())
	defer cancel()

	storeHandler := &StoreServer{}
	mux := http.NewServeMux()
	path, handler := storev1connect.NewStoreInformationAPIHandler(storeHandler)
	mux.Handle(path, handler)

	s := http.Server{
		Addr: "localhost:8080",
		// Use h2c so we can serve HTTP/2 without TLS.
		Handler: h2c.NewHandler(mux, &http2.Server{}),
	}

	g, ctx := errgroup.WithContext(ctx)

	g.Go(func() error {
		log.Printf("Starting server on %s", s.Addr)
		err := s.ListenAndServe()
		if err != nil && !errors.Is(err, http.ErrServerClosed) {
			return err
		}
		return nil
	})

	g.Go(func() error {
		<-ctx.Done()
		// Shut down context on Ctrl+C
		return s.Shutdown(context.Background()) //nolint:contextcheck
	})

	err := g.Wait()
	if err != nil && !signals.IsSignalErr(ctx) {
		log.Fatalf("Unexpected server shut down: %v", err)
	}
	log.Println("Server shut down gracefully")
}

// A map from store-id to store-name
var stores = map[string]string{
	"1": "Grorud",
	"2": "Oslo S",
}

// StoreServer implements the ConnectRPC StoreInformation server.
type StoreServer struct{}

// GetStore looks up the requested store.
func (s *StoreServer) GetStore(_ context.Context, req *connect.Request[storev1.GetStoreRequest]) (*connect.Response[storev1.GetStoreResponse], error) {
	log.Println("Request headers: ", req.Header())

	storeName, ok := stores[req.Msg.GetId()]
	if !ok {
		return nil, connect.NewError(connect.CodeNotFound, fmt.Errorf("No store found"))
	}

	res := connect.NewResponse(&storev1.GetStoreResponse{
		Store: &storev1.Store{
			Id:   req.Msg.GetId(),
			Name: storeName,
		},
	})
	return res, nil
}

// gRPC method signature:
// func (s *StoreServer) GetStore(ctx context.Context, req *storev1.GetStoreRequest) (*storev1.GetStoreResponse, error)
